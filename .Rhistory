y1<-cbind(1, y) 			# we add intercept to new data
mds.new<-y1 %*% B 		# forecast for new coordinates of new points
points(mds.new, pch=21, bg="red")
rm(list=ls())
bank <- read.csv('/Users/aleksander/Desktop/Praca/Empik Case/bank_data_prediction_task.csv')
summary(bank[bank$test_control_flag == 'campaign group', ])
sum(bank$y[bank$test_control_flag == 'campaign group'])
str(bank)
bank$test_control_flag
prop.table(table(bank$test_control_flag, bank$y))
head(bank)
bank$y <- as.factor(ifelse(bank$y == 'yes', 1, 0))
summary(bank)
prop.table(table(bank$y))
# Deleting the duration as suggested on the UCL website
bank <- select(bank, -c('duration', 'X'))
# Age
ggplot(bank, aes(x = age)) +
geom_bar() +
facet_grid(y ~ ., scales = 'free_y') +
geom_vline(xintercept = c(30, 60), col = "blue",linetype = "dashed") +
scale_x_continuous(breaks = seq(0, 100, 5))
bank = bank %>%
mutate(age = ifelse(age > 60, 'old', ifelse(age > 30, 'middle', 'young')))
bank$age <- as.factor(bank$age)
table_job <- table(bank$job, bank$y)
mosaicplot(table_job, color = T)
bank = bank %>%
filter(job != "unknown")
# marital
table_marital <- table(bank$marital, bank$y)
mosaicplot(table_marital, color = T)
CrossTable(bank$marital, bank$y)
ggplot(bank, aes(x = marital, fill = y)) +
geom_bar()
library(dplyr)
library(gmodels)
library(ggplot2)
rm(list=ls())
bank <- read.csv('/Users/aleksander/Desktop/Praca/Empik Case/bank_data_prediction_task.csv')
summary(bank[bank$test_control_flag == 'campaign group', ])
sum(bank$y[bank$test_control_flag == 'campaign group'])
str(bank)
bank$test_control_flag
prop.table(table(bank$test_control_flag, bank$y))
head(bank)
bank$y <- as.factor(ifelse(bank$y == 'yes', 1, 0))
summary(bank)
prop.table(table(bank$y))
# Deleting the duration as suggested on the UCL website
bank <- select(bank, -c('duration', 'X'))
# Age
ggplot(bank, aes(x = age)) +
geom_bar() +
facet_grid(y ~ ., scales = 'free_y') +
geom_vline(xintercept = c(30, 60), col = "blue",linetype = "dashed") +
scale_x_continuous(breaks = seq(0, 100, 5))
bank = bank %>%
mutate(age = ifelse(age > 60, 'old', ifelse(age > 30, 'middle', 'young')))
bank$age <- as.factor(bank$age)
table_job <- table(bank$job, bank$y)
mosaicplot(table_job, color = T)
bank = bank %>%
filter(job != "unknown")
# marital
table_marital <- table(bank$marital, bank$y)
mosaicplot(table_marital, color = T)
CrossTable(bank$marital, bank$y)
ggplot(bank, aes(x = marital, fill = y)) +
geom_bar()
# education
table_educ <- table(bank$education, bank$y)
mosaicplot(table_educ, color = T)
# it seems like illiterate is a very small number of cases
nrow(bank[bank$education == 'illiterate',])
# since its only 18 of this cases that will bias our algorithm later, we remove observations that have writen 'illiterate' in their education
bank = bank %>%
filter(education != 'illiterate')
summary(bank$default)
# No differentation -> I remove the variable
bank <- select(bank, -c('default'))
# LOAN
summary(bank$loan)
CrossTable(bank$loan, bank$y, prop.c = F, prop.t = F, prop.chisq = F)
# HOUSING
CrossTable(bank$housing, bank$y, prop.c = F, prop.t = F, prop.chisq = F)
chisq.test(bank$housing, bank$y)
nrow(bank[bank$housing == 'unknown' & bank$loan == 'unknown', ] )
# Removing the observations where housing or loan are unknown
bank = bank %>%
filter(housing != 'unknown' & bank$loan != 'unknown')
# Let's for now skip 5 variables related to the last contact of the current campaign
bank$pdays_binary <- as.factor(ifelse(bank$pdays == 999, 0, 1))
CrossTable(bank$pdays_binary, bank$y, prop.c = F, prop.t = F, prop.chisq = F)
bank <- select(bank, -c('pdays'))
# Pdays binary seems to be easily interpretable and highly differential variable. It shows that those who were contacted at all
#
bank = bank %>%
mutate(previous = ifelse(previous >= 2, "2 or more", ifelse(previous == 1, "1", "0")))
CrossTable(bank$previous, bank$y, prop.c = F, prop.t = F, prop.chisq = F)
CrossTable(bank$poutcome, bank$y, prop.c = F, prop.t = F, prop.chisq = F)
library(corrplot)
?corrplot
bank = bank %>%
filter(is.na(cons.price.idx) == FALSE)
social <- bank %>%
select(emp.var.rate, cons.price.idx, cons.conf.idx, euribor3m, nr.employed)
cor_social <- cor(social)
corrplot(cor_social, method = 'number', type = 'upper')
bank <- select(bank, -c('emp.var.rate'))
sum(bank$test_control_flag == 'control group') / nrow(bank)
library("Information")
bank$y <- ifelse(bank$y == '1', 1, 0)
IV <- create_infotables(data = bank, y = "y", bins = 5, parallel = FALSE)
IV$Summary
bank <- select(bank, -c('contact', 'month', 'day_of_week', 'campaign'))
bank <- na.omit(bank)
# Przelosowanie danych
bank <- bank[sample(nrow(bank)), ]
bank$y <- as.factor(bank$y)
train_proportion <- 0.7
train_index <- runif(nrow(bank)) < train_proportion
train <- bank[train_index,]
test <- bank[!train_index,]
summary(test)
library(rpart) # do drzewa
library(rpart.plot) # do rysowania drzewa
library(ROCR) # do krzywej ROC
library(caret) # do waznosci zmiennych w modelu
model <- train(
y ~., data = train, method = "rpart",
trControl = trainControl("cv", number = 5),
tuneLength = 10
)
plot(model)
model$bestTune
tree1 <- rpart(y ~ ., data = train, cp = 0.001065582)
#rpart.plot(d.klas1, under=FALSE, fallen.leaves = FALSE, cex = 0.6)
rpart.plot(tree1, under = F, fallen.leaves = F, cex = 0.6)
tree1_prediction <- predict(tree1, newdata = test, type = 'class')
confusionMatrix(tree1_prediction, test$y, positive = '1')
# ROC Curve and AUC
p <- predict(tree1, test, type = 'p')
colAUC(p, test$y, plotROC = T)
# ROC Curve and AUC
library(caTools)
colAUC(p, test$y, plotROC = T)
rm(list=ls())
rm(list=ls())
bank <- read.csv('/Users/aleksander/Desktop/Praca/Empik Case/bank_data_prediction_task.csv')
summary(bank[bank$test_control_flag == 'campaign group', ])
sum(bank$y[bank$test_control_flag == 'campaign group'])
str(bank)
bank$test_control_flag
prop.table(table(bank$test_control_flag, bank$y))
head(bank)
bank$y <- as.factor(ifelse(bank$y == 'yes', 1, 0))
summary(bank)
prop.table(table(bank$y))
# Deleting the duration as suggested on the UCL website
bank <- select(bank, -c('duration', 'X'))
# Age
ggplot(bank, aes(x = age)) +
geom_bar() +
facet_grid(y ~ ., scales = 'free_y') +
geom_vline(xintercept = c(30, 60), col = "blue",linetype = "dashed") +
scale_x_continuous(breaks = seq(0, 100, 5))
bank = bank %>%
mutate(age = ifelse(age > 60, 'old', ifelse(age > 30, 'middle', 'young')))
bank$age <- as.factor(bank$age)
table_job <- table(bank$job, bank$y)
mosaicplot(table_job, color = T)
bank = bank %>%
filter(job != "unknown")
# marital
table_marital <- table(bank$marital, bank$y)
mosaicplot(table_marital, color = T)
CrossTable(bank$marital, bank$y)
ggplot(bank, aes(x = marital, fill = y)) +
geom_bar()
# education
table_educ <- table(bank$education, bank$y)
mosaicplot(table_educ, color = T)
# it seems like illiterate is a very small number of cases
nrow(bank[bank$education == 'illiterate',])
# since its only 18 of this cases that will bias our algorithm later, we remove observations that have writen 'illiterate' in their education
bank = bank %>%
filter(education != 'illiterate')
summary(bank$default)
# No differentation -> I remove the variable
bank <- select(bank, -c('default'))
# LOAN
summary(bank$loan)
CrossTable(bank$loan, bank$y, prop.c = F, prop.t = F, prop.chisq = F)
# HOUSING
CrossTable(bank$housing, bank$y, prop.c = F, prop.t = F, prop.chisq = F)
chisq.test(bank$housing, bank$y)
nrow(bank[bank$housing == 'unknown' & bank$loan == 'unknown', ] )
# Removing the observations where housing or loan are unknown
bank = bank %>%
filter(housing != 'unknown' & bank$loan != 'unknown')
# Let's for now skip 5 variables related to the last contact of the current campaign
bank$pdays_binary <- as.factor(ifelse(bank$pdays == 999, 0, 1))
CrossTable(bank$pdays_binary, bank$y, prop.c = F, prop.t = F, prop.chisq = F)
bank <- select(bank, -c('pdays'))
# Pdays binary seems to be easily interpretable and highly differential variable. It shows that those who were contacted at all
#
bank = bank %>%
mutate(previous = ifelse(previous >= 2, "2 or more", ifelse(previous == 1, "1", "0")))
CrossTable(bank$previous, bank$y, prop.c = F, prop.t = F, prop.chisq = F)
CrossTable(bank$poutcome, bank$y, prop.c = F, prop.t = F, prop.chisq = F)
library(corrplot)
?corrplot
bank = bank %>%
filter(is.na(cons.price.idx) == FALSE)
social <- bank %>%
select(emp.var.rate, cons.price.idx, cons.conf.idx, euribor3m, nr.employed)
cor_social <- cor(social)
corrplot(cor_social, method = 'number', type = 'upper')
bank <- select(bank, -c('emp.var.rate'))
sum(bank$test_control_flag == 'control group') / nrow(bank)
library("Information")
bank$y <- ifelse(bank$y == '1', 1, 0)
IV <- create_infotables(data = bank, y = "y", bins = 5, parallel = FALSE)
IV$Summary
bank <- select(bank, -c('contact', 'month', 'day_of_week', 'campaign'))
bank <- na.omit(bank)
# Przelosowanie danych
bank <- bank[sample(nrow(bank)), ]
bank$y <- as.factor(bank$y)
train_proportion <- 0.8
train_index <- runif(nrow(bank)) < train_proportion
train <- bank[train_index,]
test <- bank[!train_index,]
summary(test)
library(rpart) # do drzewa
library(rpart.plot) # do rysowania drzewa
library(ROCR) # do krzywej ROC
library(caret) # do waznosci zmiennych w modelu
model <- train(
y ~., data = train, method = "rpart",
trControl = trainControl("cv", number = 5),
tuneLength = 10
)
plot(model)
model$bestTune
tree1 <- rpart(y ~ ., data = train, cp = 0.00152439)
#rpart.plot(d.klas1, under=FALSE, fallen.leaves = FALSE, cex = 0.6)
rpart.plot(tree1, under = F, fallen.leaves = F, cex = 0.6)
tree1_prediction <- predict(tree1, newdata = test, type = 'class')
confusionMatrix(tree1_prediction, test$y, positive = '1')
# ROC Curve and AUC
library(caTools)
p <- predict(tree1, test, type = 'p')
colAUC(p, test$y, plotROC = T)
rm(list=ls())
bank <- read.csv('/Users/aleksander/Desktop/Praca/Empik Case/bank_data_prediction_task.csv')
summary(bank[bank$test_control_flag == 'campaign group', ])
str(bank)
bank$test_control_flag
prop.table(table(bank$test_control_flag, bank$y))
head(bank)
bank$y <- as.factor(ifelse(bank$y == 'yes', 1, 0))
summary(bank)
prop.table(table(bank$y))
# Deleting the duration as suggested on the UCL website
bank <- select(bank, -c('duration', 'X'))
# Age
ggplot(bank, aes(x = age)) +
geom_bar() +
facet_grid(y ~ ., scales = 'free_y') +
geom_vline(xintercept = c(30, 60), col = "blue",linetype = "dashed") +
scale_x_continuous(breaks = seq(0, 100, 5))
bank = bank %>%
mutate(age = ifelse(age > 60, 'old', ifelse(age > 30, 'middle', 'young')))
bank$age <- as.factor(bank$age)
table_job <- table(bank$job, bank$y)
mosaicplot(table_job, color = T)
bank = bank %>%
filter(job != "unknown")
# marital
table_marital <- table(bank$marital, bank$y)
mosaicplot(table_marital, color = T)
CrossTable(bank$marital, bank$y)
ggplot(bank, aes(x = marital, fill = y)) +
geom_bar()
# education
table_educ <- table(bank$education, bank$y)
mosaicplot(table_educ, color = T)
# it seems like illiterate is a very small number of cases
nrow(bank[bank$education == 'illiterate',])
# since its only 18 of this cases that will bias our algorithm later, we remove observations that have writen 'illiterate' in their education
bank = bank %>%
filter(education != 'illiterate')
summary(bank$default)
# No differentation -> I remove the variable
bank <- select(bank, -c('default'))
# LOAN
summary(bank$loan)
CrossTable(bank$loan, bank$y, prop.c = F, prop.t = F, prop.chisq = F)
# HOUSING
CrossTable(bank$housing, bank$y, prop.c = F, prop.t = F, prop.chisq = F)
chisq.test(bank$housing, bank$y)
nrow(bank[bank$housing == 'unknown' & bank$loan == 'unknown', ] )
# Removing the observations where housing or loan are unknown
bank = bank %>%
filter(housing != 'unknown' & bank$loan != 'unknown')
# Let's for now skip 5 variables related to the last contact of the current campaign
bank$pdays_binary <- as.factor(ifelse(bank$pdays == 999, 0, 1))
CrossTable(bank$pdays_binary, bank$y, prop.c = F, prop.t = F, prop.chisq = F)
bank <- select(bank, -c('pdays'))
# Pdays binary seems to be easily interpretable and highly differential variable. It shows that those who were contacted at all
#
bank = bank %>%
mutate(previous = ifelse(previous >= 2, "2 or more", ifelse(previous == 1, "1", "0")))
CrossTable(bank$previous, bank$y, prop.c = F, prop.t = F, prop.chisq = F)
CrossTable(bank$poutcome, bank$y, prop.c = F, prop.t = F, prop.chisq = F)
library(corrplot)
?corrplot
bank = bank %>%
filter(is.na(cons.price.idx) == FALSE)
social <- bank %>%
select(emp.var.rate, cons.price.idx, cons.conf.idx, euribor3m, nr.employed)
cor_social <- cor(social)
corrplot(cor_social, method = 'number', type = 'upper')
bank <- select(bank, -c('emp.var.rate'))
sum(bank$test_control_flag == 'control group') / nrow(bank)
library("Information")
bank$y <- ifelse(bank$y == '1', 1, 0)
IV <- create_infotables(data = bank, y = "y", bins = 5, parallel = FALSE)
IV$Summary
bank <- select(bank, -c('contact', 'month', 'day_of_week', 'campaign'))
# Przelosowanie danych
bank <- bank[sample(nrow(bank)), ]
bank$y <- as.factor(bank$y)
train_proportion <- 0.8
train_index <- runif(nrow(bank)) < train_proportion
train <- bank[train_index,]
test <- bank[!train_index,]
summary(test)
library(rpart) # do drzewa
library(rpart.plot) # do rysowania drzewa
library(ROCR) # do krzywej ROC
library(caret) # do waznosci zmiennych w modelu
model <- train(
y ~., data = train, method = "rpart",
trControl = trainControl("cv", number = 5),
tuneLength = 10
)
plot(model)
model$bestTune
tree1 <- rpart(y ~ ., data = train, cp = 0.00152439)
#rpart.plot(d.klas1, under=FALSE, fallen.leaves = FALSE, cex = 0.6)
rpart.plot(tree1, under = F, fallen.leaves = F, cex = 0.6)
tree1_prediction <- predict(tree1, newdata = test, type = 'class')
confusionMatrix(tree1_prediction, test$y, positive = '1')
# ROC Curve and AUC
library(caTools)
p <- predict(tree1, test, type = 'p')
colAUC(p, test$y, plotROC = T)
model2 <- train(
y ~.,
tuneLength = 1,
data = train,
method = 'ranger',
trControl = trainControl(
method = "cv",
number = 5,
verboseIter = TRUE
)
)
plot(model2)
rm(list=ls())
bank <- read.csv('/Users/aleksander/Desktop/Praca/Empik Case/bank_data_prediction_task.csv')
summary(bank[bank$test_control_flag == 'campaign group', ])
str(bank)
bank$test_control_flag
prop.table(table(bank$test_control_flag, bank$y))
head(bank)
bank$y <- as.factor(ifelse(bank$y == 'yes', 1, 0))
summary(bank)
prop.table(table(bank$y))
# Deleting the duration as suggested on the UCL website
bank <- select(bank, -c('duration', 'X'))
# Age
ggplot(bank, aes(x = age)) +
geom_bar() +
facet_grid(y ~ ., scales = 'free_y') +
geom_vline(xintercept = c(30, 60), col = "blue",linetype = "dashed") +
scale_x_continuous(breaks = seq(0, 100, 5))
bank = bank %>%
mutate(age = ifelse(age > 60, 'old', ifelse(age > 30, 'middle', 'young')))
bank$age <- as.factor(bank$age)
table_job <- table(bank$job, bank$y)
mosaicplot(table_job, color = T)
bank = bank %>%
filter(job != "unknown")
# marital
table_marital <- table(bank$marital, bank$y)
mosaicplot(table_marital, color = T)
CrossTable(bank$marital, bank$y)
ggplot(bank, aes(x = marital, fill = y)) +
geom_bar()
# education
table_educ <- table(bank$education, bank$y)
mosaicplot(table_educ, color = T)
# it seems like illiterate is a very small number of cases
nrow(bank[bank$education == 'illiterate',])
# since its only 18 of this cases that will bias our algorithm later, we remove observations that have writen 'illiterate' in their education
bank = bank %>%
filter(education != 'illiterate')
summary(bank$default)
# No differentation -> I remove the variable
bank <- select(bank, -c('default'))
# LOAN
summary(bank$loan)
CrossTable(bank$loan, bank$y, prop.c = F, prop.t = F, prop.chisq = F)
# HOUSING
CrossTable(bank$housing, bank$y, prop.c = F, prop.t = F, prop.chisq = F)
chisq.test(bank$housing, bank$y)
nrow(bank[bank$housing == 'unknown' & bank$loan == 'unknown', ] )
# Removing the observations where housing or loan are unknown
bank = bank %>%
filter(housing != 'unknown' & bank$loan != 'unknown')
# Let's for now skip 5 variables related to the last contact of the current campaign
bank$pdays_binary <- as.factor(ifelse(bank$pdays == 999, 0, 1))
CrossTable(bank$pdays_binary, bank$y, prop.c = F, prop.t = F, prop.chisq = F)
bank <- select(bank, -c('pdays'))
# Pdays binary seems to be easily interpretable and highly differential variable. It shows that those who were contacted at all
#
bank = bank %>%
mutate(previous = ifelse(previous >= 2, "2 or more", ifelse(previous == 1, "1", "0")))
CrossTable(bank$previous, bank$y, prop.c = F, prop.t = F, prop.chisq = F)
CrossTable(bank$poutcome, bank$y, prop.c = F, prop.t = F, prop.chisq = F)
library(corrplot)
?corrplot
bank = bank %>%
filter(is.na(cons.price.idx) == FALSE)
social <- bank %>%
select(emp.var.rate, cons.price.idx, cons.conf.idx, euribor3m, nr.employed)
cor_social <- cor(social)
corrplot(cor_social, method = 'number', type = 'upper')
bank <- select(bank, -c('emp.var.rate'))
sum(bank$test_control_flag == 'control group') / nrow(bank)
library("Information")
bank$y <- ifelse(bank$y == '1', 1, 0)
IV <- create_infotables(data = bank, y = "y", bins = 5, parallel = FALSE)
IV$Summary
#bank <- select(bank, -c('contact', 'month', 'day_of_week', 'campaign'))
bank <- na.omit(bank)
# Przelosowanie danych
bank <- bank[sample(nrow(bank)), ]
bank$y <- as.factor(bank$y)
train_proportion <- 0.8
train_index <- runif(nrow(bank)) < train_proportion
train <- bank[train_index,]
test <- bank[!train_index,]
summary(test)
library(rpart) # do drzewa
library(rpart.plot) # do rysowania drzewa
library(ROCR) # do krzywej ROC
library(caret) # do waznosci zmiennych w modelu
model <- train(
y ~., data = train, method = "rpart",
trControl = trainControl("cv", number = 5),
tuneLength = 10
)
plot(model)
model$bestTune
tree1 <- rpart(y ~ ., data = train, cp = 0.003582395)
#rpart.plot(d.klas1, under=FALSE, fallen.leaves = FALSE, cex = 0.6)
rpart.plot(tree1, under = F, fallen.leaves = F, cex = 0.6)
tree1_prediction <- predict(tree1, newdata = test, type = 'class')
confusionMatrix(tree1_prediction, test$y, positive = '1')
# ROC Curve and AUC
library(caTools)
p <- predict(tree1, test, type = 'p')
colAUC(p, test$y, plotROC = T)
?mtcars
numbers <- list(
x = c(1, 2, 3),
y = c('one', 'two', 'three'),
z = c('uno', 'dos', 'tres')
)
[1]numbers
numbers
numbers[1]
setwd("~/Desktop/programowanie/R/kopia_repo/shiny_web_app_geo")
rm(list = ls())
library(shiny); runApp('geo_app.R')
library('tidygeocoder')
library(shiny)
library(dplyr)
library("sf")
library(shinydashboard)
library(shinyjs)
library(leaflet)
library('tidygeocoder')
library(osmdata)
library(osrm)
library(rgdal)
runApp('geo_app.R')
install.packages("shinydashboard")
library(shiny); runApp('geo_app.R')
runApp('geo_app.R')
install.packages("shinydashboard")
library(shiny); runApp('geo_app.R')
?str_split
library(stringr)
runApp('geo_app.R')
install.packages("shinydashboard")
library(shiny); runApp('geo_app.R')
